.rst
.pdf
Tools
Tools
#
Core toolkit implementations.
pydantic
model
langchain.tools.
AIPluginTool
[source]
#
field
api_spec
:
str
[Required]
#
field
args_schema
:
Type
[
AIPluginToolSchema
]
=
<class
'langchain.tools.plugin.AIPluginToolSchema'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
plugin
:
AIPlugin
[Required]
#
classmethod
from_plugin_url
(
url
:
str
)
→
langchain.tools.plugin.AIPluginTool
[source]
#
pydantic
model
langchain.tools.
APIOperation
[source]
#
A model for a single API operation.
field
base_url
:
str
[Required]
#
The base URL of the operation.
field
description
:
Optional
[
str
]
=
None
#
The description of the operation.
field
method
:
langchain.tools.openapi.utils.openapi_utils.HTTPVerb
[Required]
#
The HTTP method of the operation.
field
operation_id
:
str
[Required]
#
The unique identifier of the operation.
field
path
:
str
[Required]
#
The path of the operation.
field
properties
:
Sequence
[
langchain.tools.openapi.utils.api_models.APIProperty
]
[Required]
#
field
request_body
:
Optional
[
langchain.tools.openapi.utils.api_models.APIRequestBody
]
=
None
#
The request body of the operation.
classmethod
from_openapi_spec
(
spec
:
langchain.tools.openapi.utils.openapi_utils.OpenAPISpec
,
path
:
str
,
method
:
str
)
→
langchain.tools.openapi.utils.api_models.APIOperation
[source]
#
Create an APIOperation from an OpenAPI spec.
classmethod
from_openapi_url
(
spec_url
:
str
,
path
:
str
,
method
:
str
)
→
langchain.tools.openapi.utils.api_models.APIOperation
[source]
#
Create an APIOperation from an OpenAPI URL.
to_typescript
(
)
→
str
[source]
#
Get typescript string representation of the operation.
static
ts_type_from_python
(
type_
:
Union
[
str
,
Type
,
tuple
,
None
,
enum.Enum
]
)
→
str
[source]
#
property
body_params
:
List
[
str
]
#
property
path_params
:
List
[
str
]
#
property
query_params
:
List
[
str
]
#
pydantic
model
langchain.tools.
AzureCogsFormRecognizerTool
[source]
#
Tool that queries the Azure Cognitive Services Form Recognizer API.
In order to set this up, follow instructions at:
https://learn.microsoft.com/en-us/azure/applied-ai-services/form-recognizer/quickstarts/get-started-sdks-rest-api?view=form-recog-3.0.0&pivots=programming-language-python
pydantic
model
langchain.tools.
AzureCogsImageAnalysisTool
[source]
#
Tool that queries the Azure Cognitive Services Image Analysis API.
In order to set this up, follow instructions at:
https://learn.microsoft.com/en-us/azure/cognitive-services/computer-vision/quickstarts-sdk/image-analysis-client-library-40
pydantic
model
langchain.tools.
AzureCogsSpeech2TextTool
[source]
#
Tool that queries the Azure Cognitive Services Speech2Text API.
In order to set this up, follow instructions at:
https://learn.microsoft.com/en-us/azure/cognitive-services/speech-service/get-started-speech-to-text?pivots=programming-language-python
pydantic
model
langchain.tools.
AzureCogsText2SpeechTool
[source]
#
Tool that queries the Azure Cognitive Services Text2Speech API.
In order to set this up, follow instructions at:
https://learn.microsoft.com/en-us/azure/cognitive-services/speech-service/get-started-text-to-speech?pivots=programming-language-python
pydantic
model
langchain.tools.
BaseTool
[source]
#
Interface LangChain tools must implement.
field
args_schema
:
Optional
[
Type
[
pydantic.main.BaseModel
]
]
=
None
#
Pydantic model class to validate and parse the tool’s input arguments.
field
callback_manager
:
Optional
[
langchain.callbacks.base.BaseCallbackManager
]
=
None
#
Deprecated. Please use callbacks instead.
field
callbacks
:
Optional
[
Union
[
List
[
langchain.callbacks.base.BaseCallbackHandler
]
,
langchain.callbacks.base.BaseCallbackManager
]
]
=
None
#
Callbacks to be called during tool execution.
field
description
:
str
[Required]
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
handle_tool_error
:
Optional
[
Union
[
bool
,
str
,
Callable
[
[
langchain.tools.base.ToolException
]
,
str
]
]
]
=
False
#
Handle the content of the ToolException thrown.
field
name
:
str
[Required]
#
The unique name of the tool that clearly communicates its purpose.
field
return_direct
:
bool
=
False
#
Whether to return the tool’s output directly. Setting this to True means
that after the tool is called, the AgentExecutor will stop looping.
field
verbose
:
bool
=
False
#
Whether to log the tool’s progress.
async
arun
(
tool_input
:
Union
[
str
,
Dict
]
,
verbose
:
Optional
[
bool
]
=
None
,
start_color
:
Optional
[
str
]
=
'green'
,
color
:
Optional
[
str
]
=
'green'
,
callbacks
:
Optional
[
Union
[
List
[
langchain.callbacks.base.BaseCallbackHandler
]
,
langchain.callbacks.base.BaseCallbackManager
]
]
=
None
,
**
kwargs
:
Any
)
→
Any
[source]
#
Run the tool asynchronously.
run
(
tool_input
:
Union
[
str
,
Dict
]
,
verbose
:
Optional
[
bool
]
=
None
,
start_color
:
Optional
[
str
]
=
'green'
,
color
:
Optional
[
str
]
=
'green'
,
callbacks
:
Optional
[
Union
[
List
[
langchain.callbacks.base.BaseCallbackHandler
]
,
langchain.callbacks.base.BaseCallbackManager
]
]
=
None
,
**
kwargs
:
Any
)
→
Any
[source]
#
Run the tool.
property
args
:
dict
#
property
is_single_input
:
bool
#
Whether the tool only accepts a single input.
pydantic
model
langchain.tools.
BingSearchResults
[source]
#
Tool that has capability to query the Bing Search API and get back json.
field
api_wrapper
:
langchain.utilities.bing_search.BingSearchAPIWrapper
[Required]
#
field
num_results
:
int
=
4
#
pydantic
model
langchain.tools.
BingSearchRun
[source]
#
Tool that adds the capability to query the Bing search API.
field
api_wrapper
:
langchain.utilities.bing_search.BingSearchAPIWrapper
[Required]
#
pydantic
model
langchain.tools.
BraveSearch
[source]
#
field
search_wrapper
:
BraveSearchWrapper
[Required]
#
classmethod
from_api_key
(
api_key
:
str
,
search_kwargs
:
Optional
[
dict
]
=
None
,
**
kwargs
:
Any
)
→
langchain.tools.brave_search.tool.BraveSearch
[source]
#
pydantic
model
langchain.tools.
ClickTool
[source]
#
field
args_schema
:
Type
[
BaseModel
]
=
<class
'langchain.tools.playwright.click.ClickToolInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Click
on
an
element
with
the
given
CSS
selector'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'click_element'
#
The unique name of the tool that clearly communicates its purpose.
field
playwright_strict
:
bool
=
False
#
Whether to employ Playwright’s strict mode when clicking on elements.
field
playwright_timeout
:
float
=
1000
#
Timeout (in ms) for Playwright to wait for element to be ready.
field
visible_only
:
bool
=
True
#
Whether to consider only visible elements.
pydantic
model
langchain.tools.
CopyFileTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.copy.FileCopyInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Create
a
copy
of
a
file
in
a
specified
location'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'copy_file'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
CurrentWebPageTool
[source]
#
field
args_schema
:
Type
[
BaseModel
]
=
<class
'pydantic.main.BaseModel'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Returns
the
URL
of
the
current
page'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'current_webpage'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
DeleteFileTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.delete.FileDeleteInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Delete
a
file'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'file_delete'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
DuckDuckGoSearchResults
[source]
#
Tool that queries the Duck Duck Go Search API and get back json.
field
api_wrapper
:
langchain.utilities.duckduckgo_search.DuckDuckGoSearchAPIWrapper
[Optional]
#
field
num_results
:
int
=
4
#
pydantic
model
langchain.tools.
DuckDuckGoSearchRun
[source]
#
Tool that adds the capability to query the DuckDuckGo search API.
field
api_wrapper
:
langchain.utilities.duckduckgo_search.DuckDuckGoSearchAPIWrapper
[Optional]
#
pydantic
model
langchain.tools.
ExtractHyperlinksTool
[source]
#
Extract all hyperlinks on the page.
field
args_schema
:
Type
[
BaseModel
]
=
<class
'langchain.tools.playwright.extract_hyperlinks.ExtractHyperlinksToolInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Extract
all
hyperlinks
on
the
current
webpage'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'extract_hyperlinks'
#
The unique name of the tool that clearly communicates its purpose.
static
scrape_page
(
page
:
Any
,
html_content
:
str
,
absolute_urls
:
bool
)
→
str
[source]
#
pydantic
model
langchain.tools.
ExtractTextTool
[source]
#
field
args_schema
:
Type
[
BaseModel
]
=
<class
'pydantic.main.BaseModel'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Extract
all
the
text
on
the
current
webpage'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'extract_text'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
FileSearchTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.file_search.FileSearchInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Recursively
search
for
files
in
a
subdirectory
that
match
the
regex
pattern'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'file_search'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GetElementsTool
[source]
#
field
args_schema
:
Type
[
BaseModel
]
=
<class
'langchain.tools.playwright.get_elements.GetElementsToolInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Retrieve
elements
in
the
current
web
page
matching
the
given
CSS
selector'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'get_elements'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GmailCreateDraft
[source]
#
field
args_schema
:
Type
[
langchain.tools.gmail.create_draft.CreateDraftSchema
]
=
<class
'langchain.tools.gmail.create_draft.CreateDraftSchema'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Use
this
tool
to
create
a
draft
email
with
the
provided
message
fields.'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'create_gmail_draft'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GmailGetMessage
[source]
#
field
args_schema
:
Type
[
langchain.tools.gmail.get_message.SearchArgsSchema
]
=
<class
'langchain.tools.gmail.get_message.SearchArgsSchema'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Use
this
tool
to
fetch
an
email
by
message
ID.
Returns
the
thread
ID,
snipet,
body,
subject,
and
sender.'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'get_gmail_message'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GmailGetThread
[source]
#
field
args_schema
:
Type
[
langchain.tools.gmail.get_thread.GetThreadSchema
]
=
<class
'langchain.tools.gmail.get_thread.GetThreadSchema'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Use
this
tool
to
search
for
email
messages.
The
input
must
be
a
valid
Gmail
query.
The
output
is
a
JSON
list
of
messages.'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'get_gmail_thread'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GmailSearch
[source]
#
field
args_schema
:
Type
[
langchain.tools.gmail.search.SearchArgsSchema
]
=
<class
'langchain.tools.gmail.search.SearchArgsSchema'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Use
this
tool
to
search
for
email
messages
or
threads.
The
input
must
be
a
valid
Gmail
query.
The
output
is
a
JSON
list
of
the
requested
resource.'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'search_gmail'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GmailSendMessage
[source]
#
field
description
:
str
=
'Use
this
tool
to
send
email
messages.
The
input
is
the
message,
recipents'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'send_gmail_message'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
GooglePlacesTool
[source]
#
Tool that adds the capability to query the Google places API.
field
api_wrapper
:
langchain.utilities.google_places_api.GooglePlacesAPIWrapper
[Optional]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.google_places.tool.GooglePlacesSchema'>
#
Pydantic model class to validate and parse the tool’s input arguments.
pydantic
model
langchain.tools.
GoogleSearchResults
[source]
#
Tool that has capability to query the Google Search API and get back json.
field
api_wrapper
:
langchain.utilities.google_search.GoogleSearchAPIWrapper
[Required]
#
field
num_results
:
int
=
4
#
pydantic
model
langchain.tools.
GoogleSearchRun
[source]
#
Tool that adds the capability to query the Google search API.
field
api_wrapper
:
langchain.utilities.google_search.GoogleSearchAPIWrapper
[Required]
#
pydantic
model
langchain.tools.
GoogleSerperResults
[source]
#
Tool that has capability to query the Serper.dev Google Search API
and get back json.
field
api_wrapper
:
langchain.utilities.google_serper.GoogleSerperAPIWrapper
[Optional]
#
pydantic
model
langchain.tools.
GoogleSerperRun
[source]
#
Tool that adds the capability to query the Serper.dev Google search API.
field
api_wrapper
:
langchain.utilities.google_serper.GoogleSerperAPIWrapper
[Required]
#
pydantic
model
langchain.tools.
HumanInputRun
[source]
#
Tool that adds the capability to ask user for input.
field
input_func
:
Callable
[Optional]
#
field
prompt_func
:
Callable
[
[
str
]
,
None
]
[Optional]
#
pydantic
model
langchain.tools.
IFTTTWebhook
[source]
#
IFTTT Webhook.
Parameters
name
– name of the tool
description
– description of the tool
url
– url to hit with the json event.
field
url
:
str
[Required]
#
pydantic
model
langchain.tools.
InfoPowerBITool
[source]
#
Tool for getting metadata about a PowerBI Dataset.
field
powerbi
:
langchain.utilities.powerbi.PowerBIDataset
[Required]
#
pydantic
model
langchain.tools.
ListDirectoryTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.list_dir.DirectoryListingInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'List
files
and
directories
in
a
specified
folder'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'list_directory'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
ListPowerBITool
[source]
#
Tool for getting tables names.
field
powerbi
:
langchain.utilities.powerbi.PowerBIDataset
[Required]
#
pydantic
model
langchain.tools.
MetaphorSearchResults
[source]
#
Tool that has capability to query the Metaphor Search API and get back json.
field
api_wrapper
:
langchain.utilities.metaphor_search.MetaphorSearchAPIWrapper
[Required]
#
pydantic
model
langchain.tools.
MoveFileTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.move.FileMoveInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Move
or
rename
a
file
from
one
location
to
another'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'move_file'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
NavigateBackTool
[source]
#
Navigate back to the previous page in the browser history.
field
args_schema
:
Type
[
BaseModel
]
=
<class
'pydantic.main.BaseModel'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Navigate
back
to
the
previous
page
in
the
browser
history'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'previous_webpage'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
NavigateTool
[source]
#
field
args_schema
:
Type
[
BaseModel
]
=
<class
'langchain.tools.playwright.navigate.NavigateToolInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Navigate
a
browser
to
the
specified
URL'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'navigate_browser'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
OpenAPISpec
[source]
#
OpenAPI Model that removes misformatted parts of the spec.
classmethod
from_file
(
path
:
Union
[
str
,
pathlib.Path
]
)
→
langchain.tools.openapi.utils.openapi_utils.OpenAPISpec
[source]
#
Get an OpenAPI spec from a file path.
classmethod
from_spec_dict
(
spec_dict
:
dict
)
→
langchain.tools.openapi.utils.openapi_utils.OpenAPISpec
[source]
#
Get an OpenAPI spec from a dict.
classmethod
from_text
(
text
:
str
)
→
langchain.tools.openapi.utils.openapi_utils.OpenAPISpec
[source]
#
Get an OpenAPI spec from a text.
classmethod
from_url
(
url
:
str
)
→
langchain.tools.openapi.utils.openapi_utils.OpenAPISpec
[source]
#
Get an OpenAPI spec from a URL.
static
get_cleaned_operation_id
(
operation
:
openapi_schema_pydantic.v3.v3_1_0.operation.Operation
,
path
:
str
,
method
:
str
)
→
str
[source]
#
Get a cleaned operation id from an operation id.
get_methods_for_path
(
path
:
str
)
→
List
[
str
]
[source]
#
Return a list of valid methods for the specified path.
get_operation
(
path
:
str
,
method
:
str
)
→
openapi_schema_pydantic.v3.v3_1_0.operation.Operation
[source]
#
Get the operation object for a given path and HTTP method.
get_parameters_for_operation
(
operation
:
openapi_schema_pydantic.v3.v3_1_0.operation.Operation
)
→
List
[
openapi_schema_pydantic.v3.v3_1_0.parameter.Parameter
]
[source]
#
Get the components for a given operation.
get_referenced_schema
(
ref
:
openapi_schema_pydantic.v3.v3_1_0.reference.Reference
)
→
openapi_schema_pydantic.v3.v3_1_0.schema.Schema
[source]
#
Get a schema (or nested reference) or err.
get_request_body_for_operation
(
operation
:
openapi_schema_pydantic.v3.v3_1_0.operation.Operation
)
→
Optional
[
openapi_schema_pydantic.v3.v3_1_0.request_body.RequestBody
]
[source]
#
Get the request body for a given operation.
classmethod
parse_obj
(
obj
:
dict
)
→
langchain.tools.openapi.utils.openapi_utils.OpenAPISpec
[source]
#
property
base_url
:
str
#
Get the base url.
pydantic
model
langchain.tools.
OpenWeatherMapQueryRun
[source]
#
Tool that adds the capability to query using the OpenWeatherMap API.
field
api_wrapper
:
langchain.utilities.openweathermap.OpenWeatherMapAPIWrapper
[Optional]
#
pydantic
model
langchain.tools.
PubmedQueryRun
[source]
#
Tool that adds the capability to search using the PubMed API.
field
api_wrapper
:
langchain.utilities.pupmed.PubMedAPIWrapper
[Optional]
#
pydantic
model
langchain.tools.
QueryPowerBITool
[source]
#
Tool for querying a Power BI Dataset.
Validators
raise_deprecation
»
all
fields
validate_llm_chain_input_variables
»
llm_chain
field
examples
:
Optional
[
str
]
=
'\nQuestion:
How
many
rows
are
in
the
table
<table>?\nDAX:
EVALUATE
ROW("Number
of
rows",
COUNTROWS(<table>))\n----\nQuestion:
How
many
rows
are
in
the
table
<table>
where
<column>
is
not
empty?\nDAX:
EVALUATE
ROW("Number
of
rows",
COUNTROWS(FILTER(<table>,
<table>[<column>]
<>
"")))\n----\nQuestion:
What
was
the
average
of
<column>
in
<table>?\nDAX:
EVALUATE
ROW("Average",
AVERAGE(<table>[<column>]))\n----\n'
#
field
llm_chain
:
langchain.chains.llm.LLMChain
[Required]
#
field
max_iterations
:
int
=
5
#
field
powerbi
:
langchain.utilities.powerbi.PowerBIDataset
[Required]
#
field
session_cache
:
Dict
[
str
,
Any
]
[Optional]
#
field
template
:
Optional
[
str
]
=
'\nAnswer
the
question
below
with
a
DAX
query
that
can
be
sent
to
Power
BI.
DAX
queries
have
a
simple
syntax
comprised
of
just
one
required
keyword,
EVALUATE,
and
several
optional
keywords:
ORDER
BY,
START
AT,
DEFINE,
MEASURE,
VAR,
TABLE,
and
COLUMN.
Each
keyword
defines
a
statement
used
for
the
duration
of
the
query.
Any
time
<
or
>
are
used
in
the
text
below
it
means
that
those
values
need
to
be
replaced
by
table,
columns
or
other
things.
If
the
question
is
not
something
you
can
answer
with
a
DAX
query,
reply
with
"I
cannot
answer
this"
and
the
question
will
be
escalated
to
a
human.\n\nSome
DAX
functions
return
a
table
instead
of
a
scalar,
and
must
be
wrapped
in
a
function
that
evaluates
the
table
and
returns
a
scalar;
unless
the
table
is
a
single
column,
single
row
table,
then
it
is
treated
as
a
scalar
value.
Most
DAX
functions
require
one
or
more
arguments,
which
can
include
tables,
columns,
expressions,
and
values.
However,
some
functions,
such
as
PI,
do
not
require
any
arguments,
but
always
require
parentheses
to
indicate
the
null
argument.
For
example,
you
must
always
type
PI(),
not
PI.
You
can
also
nest
functions
within
other
functions.
\n\nSome
commonly
used
functions
are:\nEVALUATE
<table>
-
At
the
most
basic
level,
a
DAX
query
is
an
EVALUATE
statement
containing
a
table
expression.
At
least
one
EVALUATE
statement
is
required,
however,
a
query
can
contain
any
number
of
EVALUATE
statements.\nEVALUATE
<table>
ORDER
BY
<expression>
ASC
or
DESC
-
The
optional
ORDER
BY
keyword
defines
one
or
more
expressions
used
to
sort
query
results.
Any
expression
that
can
be
evaluated
for
each
row
of
the
result
is
valid.\nEVALUATE
<table>
ORDER
BY
<expression>
ASC
or
DESC
START
AT
<value>
or
<parameter>
-
The
optional
START
AT
keyword
is
used
inside
an
ORDER
BY
clause.
It
defines
the
value
at
which
the
query
results
begin.\nDEFINE
MEASURE
|
VAR;
EVALUATE
<table>
-
The
optional
DEFINE
keyword
introduces
one
or
more
calculated
entity
definitions
that
exist
only
for
the
duration
of
the
query.
Definitions
precede
the
EVALUATE
statement
and
are
valid
for
all
EVALUATE
statements
in
the
query.
Definitions
can
be
variables,
measures,
tables1,
and
columns1.
Definitions
can
reference
other
definitions
that
appear
before
or
after
the
current
definition.
At
least
one
definition
is
required
if
the
DEFINE
keyword
is
included
in
a
query.\nMEASURE
<table
name>[<measure
name>]
=
<scalar
expression>
-
Introduces
a
measure
definition
in
a
DEFINE
statement
of
a
DAX
query.\nVAR
<name>
=
<expression>
-
Stores
the
result
of
an
expression
as
a
named
variable,
which
can
then
be
passed
as
an
argument
to
other
measure
expressions.
Once
resultant
values
have
been
calculated
for
a
variable
expression,
those
values
do
not
change,
even
if
the
variable
is
referenced
in
another
expression.\n\nFILTER(<table>,<filter>)
-
Returns
a
table
that
represents
a
subset
of
another
table
or
expression,
where
<filter>
is
a
Boolean
expression
that
is
to
be
evaluated
for
each
row
of
the
table.
For
example,
[Amount]
>
0
or
[Region]
=
"France"\nROW(<name>,
<expression>)
-
Returns
a
table
with
a
single
row
containing
values
that
result
from
the
expressions
given
to
each
column.\nDISTINCT(<column>)
-
Returns
a
one-column
table
that
contains
the
distinct
values
from
the
specified
column.
In
other
words,
duplicate
values
are
removed
and
only
unique
values
are
returned.
This
function
cannot
be
used
to
Return
values
into
a
cell
or
column
on
a
worksheet;
rather,
you
nest
the
DISTINCT
function
within
a
formula,
to
get
a
list
of
distinct
values
that
can
be
passed
to
another
function
and
then
counted,
summed,
or
used
for
other
operations.\nDISTINCT(<table>)
-
Returns
a
table
by
removing
duplicate
rows
from
another
table
or
expression.\n\nAggregation
functions,
names
with
a
A
in
it,
handle
booleans
and
empty
strings
in
appropriate
ways,
while
the
same
function
without
A
only
uses
the
numeric
values
in
a
column.
Functions
names
with
an
X
in
it
can
include
a
expression
as
an
argument,
this
will
be
evaluated
for
each
row
in
the
table
and
the
result
will
be
used
in
the
regular
function
calculation,
these
are
the
functions:\nCOUNT(<column>),
COUNTA(<column>),
COUNTX(<table>,<expression>),
COUNTAX(<table>,<expression>),
COUNTROWS([<table>]),
COUNTBLANK(<column>),
DISTINCTCOUNT(<column>),
DISTINCTCOUNTNOBLANK
(<column>)
-
these
are
all
variantions
of
count
functions.\nAVERAGE(<column>),
AVERAGEA(<column>),
AVERAGEX(<table>,<expression>)
-
these
are
all
variantions
of
average
functions.\nMAX(<column>),
MAXA(<column>),
MAXX(<table>,<expression>)
-
these
are
all
variantions
of
max
functions.\nMIN(<column>),
MINA(<column>),
MINX(<table>,<expression>)
-
these
are
all
variantions
of
min
functions.\nPRODUCT(<column>),
PRODUCTX(<table>,<expression>)
-
these
are
all
variantions
of
product
functions.\nSUM(<column>),
SUMX(<table>,<expression>)
-
these
are
all
variantions
of
sum
functions.\n\nDate
and
time
functions:\nDATE(year,
month,
day)
-
Returns
a
date
value
that
represents
the
specified
year,
month,
and
day.\nDATEDIFF(date1,
date2,
<interval>)
-
Returns
the
difference
between
two
date
values,
in
the
specified
interval,
that
can
be
SECOND,
MINUTE,
HOUR,
DAY,
WEEK,
MONTH,
QUARTER,
YEAR.\nDATEVALUE(<date_text>)
-
Returns
a
date
value
that
represents
the
specified
date.\nYEAR(<date>),
QUARTER(<date>),
MONTH(<date>),
DAY(<date>),
HOUR(<date>),
MINUTE(<date>),
SECOND(<date>)
-
Returns
the
part
of
the
date
for
the
specified
date.\n\nFinally,
make
sure
to
escape
double
quotes
with
a
single
backslash,
and
make
sure
that
only
table
names
have
single
quotes
around
them,
while
names
of
measures
or
the
values
of
columns
that
you
want
to
compare
against
are
in
escaped
double
quotes.
Newlines
are
not
necessary
and
can
be
skipped.
The
queries
are
serialized
as
json
and
so
will
have
to
fit
be
compliant
with
json
syntax.
Sometimes
you
will
get
a
question,
a
DAX
query
and
a
error,
in
that
case
you
need
to
rewrite
the
DAX
query
to
get
the
correct
answer.\n\nThe
following
tables
exist:
{tables}\n\nand
the
schema\'s
for
some
are
given
here:\n{schemas}\n\nExamples:\n{examples}\n\nQuestion:
{tool_input}\nDAX:
\n'
#
pydantic
model
langchain.tools.
ReadFileTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.read.ReadFileInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Read
file
from
disk'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'read_file'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
SceneXplainTool
[source]
#
Tool that adds the capability to explain images.
field
api_wrapper
:
langchain.utilities.scenexplain.SceneXplainAPIWrapper
[Optional]
#
pydantic
model
langchain.tools.
ShellTool
[source]
#
Tool to run shell commands.
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.shell.tool.ShellInput'>
#
Schema for input arguments.
field
description
:
str
=
'Run
shell
commands
on
this
Linux
machine.'
#
Description of tool.
field
name
:
str
=
'terminal'
#
Name of tool.
field
process
:
langchain.utilities.bash.BashProcess
[Optional]
#
Bash process to run commands.
pydantic
model
langchain.tools.
SteamshipImageGenerationTool
[source]
#
field
model_name
:
ModelName
[Required]
#
field
return_urls
:
Optional
[
bool
]
=
False
#
field
size
:
Optional
[
str
]
=
'512x512'
#
field
steamship
:
Steamship
[Required]
#
pydantic
model
langchain.tools.
StructuredTool
[source]
#
Tool that can operate on any number of inputs.
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
[Required]
#
The input arguments’ schema.
The tool schema.
field
coroutine
:
Optional
[
Callable
[
[
...
]
,
Awaitable
[
Any
]
]
]
=
None
#
The asynchronous version of the function.
field
description
:
str
=
''
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
func
:
Callable
[
[
...
]
,
Any
]
[Required]
#
The function to run when the tool is called.
classmethod
from_function
(
func
:
Callable
,
name
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
return_direct
:
bool
=
False
,
args_schema
:
Optional
[
Type
[
pydantic.main.BaseModel
]
]
=
None
,
infer_schema
:
bool
=
True
,
**
kwargs
:
Any
)
→
langchain.tools.base.StructuredTool
[source]
#
property
args
:
dict
#
The tool’s input arguments.
pydantic
model
langchain.tools.
Tool
[source]
#
Tool that takes in function or coroutine directly.
field
args_schema
:
Optional
[
Type
[
pydantic.main.BaseModel
]
]
=
None
#
Pydantic model class to validate and parse the tool’s input arguments.
field
callback_manager
:
Optional
[
langchain.callbacks.base.BaseCallbackManager
]
=
None
#
Deprecated. Please use callbacks instead.
field
callbacks
:
Optional
[
Union
[
List
[
langchain.callbacks.base.BaseCallbackHandler
]
,
langchain.callbacks.base.BaseCallbackManager
]
]
=
None
#
Callbacks to be called during tool execution.
field
coroutine
:
Optional
[
Callable
[
[
...
]
,
Awaitable
[
str
]
]
]
=
None
#
The asynchronous version of the function.
field
description
:
str
=
''
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
func
:
Callable
[
[
...
]
,
str
]
[Required]
#
The function to run when the tool is called.
field
handle_tool_error
:
Optional
[
Union
[
bool
,
str
,
Callable
[
[
langchain.tools.base.ToolException
]
,
str
]
]
]
=
False
#
Handle the content of the ToolException thrown.
field
name
:
str
[Required]
#
The unique name of the tool that clearly communicates its purpose.
field
return_direct
:
bool
=
False
#
Whether to return the tool’s output directly. Setting this to True means
that after the tool is called, the AgentExecutor will stop looping.
field
verbose
:
bool
=
False
#
Whether to log the tool’s progress.
classmethod
from_function
(
func
:
Callable
,
name
:
str
,
description
:
str
,
return_direct
:
bool
=
False
,
args_schema
:
Optional
[
Type
[
pydantic.main.BaseModel
]
]
=
None
,
**
kwargs
:
Any
)
→
langchain.tools.base.Tool
[source]
#
Initialize tool from a function.
property
args
:
dict
#
The tool’s input arguments.
pydantic
model
langchain.tools.
VectorStoreQATool
[source]
#
Tool for the VectorDBQA chain. To be initialized with name and chain.
static
get_description
(
name
:
str
,
description
:
str
)
→
str
[source]
#
pydantic
model
langchain.tools.
VectorStoreQAWithSourcesTool
[source]
#
Tool for the VectorDBQAWithSources chain.
static
get_description
(
name
:
str
,
description
:
str
)
→
str
[source]
#
pydantic
model
langchain.tools.
WikipediaQueryRun
[source]
#
Tool that adds the capability to search using the Wikipedia API.
field
api_wrapper
:
langchain.utilities.wikipedia.WikipediaAPIWrapper
[Required]
#
pydantic
model
langchain.tools.
WolframAlphaQueryRun
[source]
#
Tool that adds the capability to query using the Wolfram Alpha SDK.
field
api_wrapper
:
langchain.utilities.wolfram_alpha.WolframAlphaAPIWrapper
[Required]
#
pydantic
model
langchain.tools.
WriteFileTool
[source]
#
field
args_schema
:
Type
[
pydantic.main.BaseModel
]
=
<class
'langchain.tools.file_management.write.WriteFileInput'>
#
Pydantic model class to validate and parse the tool’s input arguments.
field
description
:
str
=
'Write
file
to
disk'
#
Used to tell the model how/when/why to use the tool.
You can provide few-shot examples as a part of the description.
field
name
:
str
=
'write_file'
#
The unique name of the tool that clearly communicates its purpose.
pydantic
model
langchain.tools.
YouTubeSearchTool
[source]
#
pydantic
model
langchain.tools.
ZapierNLAListActions
[source]
#
Returns a list of all exposed (enabled) actions associated with
current user (associated with the set api_key). Change your exposed
actions here:
https://nla.zapier.com/demo/start/
The return list can be empty if no actions exposed. Else will contain
a list of action objects:
[{
“id”: str,
“description”: str,
“params”: Dict[str, str]
}]
params
will always contain an
instructions
key, the only required
param. All others optional and if provided will override any AI guesses
(see “understanding the AI guessing flow” here:
https://nla.zapier.com/api/v1/docs
)
Parameters
None
–
field
api_wrapper
:
langchain.utilities.zapier.ZapierNLAWrapper
[Optional]
#
pydantic
model
langchain.tools.
ZapierNLARunAction
[source]
#
Executes an action that is identified by action_id, must be exposed
(enabled) by the current user (associated with the set api_key). Change
your exposed actions here:
https://nla.zapier.com/demo/start/
The return JSON is guaranteed to be less than ~500 words (350
tokens) making it safe to inject into the prompt of another LLM
call.
Parameters
action_id
– a specific action ID (from list actions) of the action to execute
(the set api_key must be associated with the action owner)
instructions
– a natural language instruction string for using the action
(eg. “get the latest email from Mike Knoop” for “Gmail: find email” action)
params
– a dict, optional. Any params provided will
override
AI guesses
from
instructions
(see “understanding the AI guessing flow” here:
https://nla.zapier.com/api/v1/docs
)
field
action_id
:
str
[Required]
#
field
api_wrapper
:
langchain.utilities.zapier.ZapierNLAWrapper
[Optional]
#
field
base_prompt
:
str
=
'A
wrapper
around
Zapier
NLA
actions.
The
input
to
this
tool
is
a
natural
language
instruction,
for
example
"get
the
latest
email
from
my
bank"
or
"send
a
slack
message
to
the
#general
channel".
Each
tool
will
have
params
associated
with
it
that
are
specified
as
a
list.
You
MUST
take
into
account
the
params
when
creating
the
instruction.
For
example,
if
the
params
are
[\'Message_Text\',
\'Channel\'],
your
instruction
should
be
something
like
\'send
a
slack
message
to
the
#general
channel
with
the
text
hello
world\'.
Another
example:
if
the
params
are
[\'Calendar\',
\'Search_Term\'],
your
instruction
should
be
something
like
\'find
the
meeting
in
my
personal
calendar
at
3pm\'.
Do
not
make
up
params,
they
will
be
explicitly
specified
in
the
tool
description.
If
you
do
not
have
enough
information
to
fill
in
the
params,
just
say
\'not
enough
information
provided
in
the
instruction,
missing
<param>\'.
If
you
get
a
none
or
null
response,
STOP
EXECUTION,
do
not
try
to
another
tool!This
tool
specifically
used
for:
{zapier_description},
and
has
params:
{params}'
#
field
params
:
Optional
[
dict
]
=
None
#
field
params_schema
:
Dict
[
str
,
str
]
[Optional]
#
field
zapier_description
:
str
[Required]
#
langchain.tools.
tool
(
*
args
:
Union
[
str
,
Callable
]
,
return_direct
:
bool
=
False
,
args_schema
:
Optional
[
Type
[
pydantic.main.BaseModel
]
]
=
None
,
infer_schema
:
bool
=
True
)
→
Callable
[source]
#
Make tools out of functions, can be used with or without arguments.
Parameters
*args
– The arguments to the tool.
return_direct
– Whether to return directly from the tool rather
than continuing the agent loop.
args_schema
– optional argument schema for user to specify
infer_schema
– Whether to infer the schema of the arguments from
the function’s signature. This also makes the resultant tool
accept a dictionary input to its
run()
function.
Requires:
Function must be of type (str) -> str
Function must have a docstring
Examples
@tool
def
search_api
(
query
:
str
)
->
str
:
# Searches the API for the query.
return
@tool
(
"search"
,
return_direct
=
True
)
def
search_api
(
query
:
str
)
->
str
:
# Searches the API for the query.
return
previous
Agents
next
Agent Toolkits
By Harrison Chase
© Copyright 2023, Harrison Chase.
Last updated on Jun 09, 2023.